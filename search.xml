<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[操作系统文件共享机制及代码演示]]></title>
    <url>%2F2019%2F05%2F25%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%9C%BA%E5%88%B6%E5%8F%8A%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[内存inode我们知道inode索引节点是UNIX操作系统的一种数据结构，它包含了与文件系统中各个文件相关的一些重要信息，当用户搜索一个文件时，操作系统会根据文件名在磁盘上的inode表中找到该文件对应的inode，该inode包含文件的属主ID，属主的组ID，文件大小，文件使用磁盘块数量，修改时间等信息。但是在实际操作中，操作系统操作的都是内存上的内容，所以内存中会有磁盘上部分的inode表中的数据或者叫做inode表的一个缓存，用于对inode的快速访问，内存中的这块inode叫做内存inode。 系统文件打开表系统文件打开表（Open file table）存在于内存放中，整个操作系统只维护一张这样的表，用于保存已经打开文件的FCB文件号、共享计数（打开共享）、读写位置、打开模式、修改标志等信息，其中还有一个比较重要的属性就是一个指向内存inode的一个指针，这个指针的作用我们后面会介绍。 用户文件打开表用户文件打开表（File Descriptor table）是每个进程都有的一张表，用于记录用户打开的文件的一些信息，主要的属性有文件描述符fd和 一个指向系统文件打开表项的指针。 不同的共享关系用户文件打开表、系统文件打开表和内存inode的关系如下 同进程复制fd 在同一个进程中共享同一个open file table表项，结果是两个文件共享一个句柄，可以dup()实现。 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;int main()&#123; int fd = open("test.txt",O_RDONLY); int fdcopy = dup(fd); char buff1[10]; char buff2[10]; read(fd, buff1, 5); read(fdcopy, buff2, 5); printf("buff1:%s\n", buff1); printf("buff2:%s\n", buff2); close(fd); close(fdcopy);&#125; 其中test.txt中的数据是： 1ABCDEFGHIJ 结果： 12buff1:ABCDEbuff2:FGHIJ 跨进程复制fd 父进程通过fork命令实现子进程对父进程的一种复制，该父子进程的用户文件打开表一样。 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;int main()&#123; int fd = open("test.txt",O_RDONLY); pid_t pid = fork(); char buff[10]; if(pid &gt; 0)&#123; read(fd, buff, 5); printf("father:%s\n", buff); &#125; else&#123; read(fd, buff, 5); printf("son:%s\n", buff); &#125; &#125; 结果： 12father:ABCDEson:FGHIJ 共享数据独立访问父子进程之间共享数据独立访问 两个进程访问同一个文件，但是其系统文件打开表指向不同。代码和上面的跨进程复制fd几乎一样，只是这个open函数在fork函数之后执行，导致两个进程file ptr分别指向系统文件打开表不同位置。 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;int main()&#123; pid_t pid = fork(); int fd = open("test.txt",O_RDONLY); char buff[10]; if(pid &gt; 0)&#123; read(fd, buff, 5); printf("father:%s\n", buff); &#125; else&#123; read(fd, buff, 5); printf("son:%s\n", buff); &#125; &#125; 结果： 12father:ABCDEson:ABCDE 同一进程之间共享数据独立访问 同一个进程操作同一文件，但是对应的系统文件打开表表项不一样。 123456789101112int main()&#123; int fd1 = open("test.txt",O_RDONLY); int fd2 = open("test.txt", O_RDONLY); char buff1[10]; char buff2[10]; read(fd1, buff1, 5); read(fd2, buff2, 5); printf("buff1:%s\n", buff1); printf("buff2:%s\n", buff2); close(fd1); close(fd2);&#125; 结果： 12buff1:ABCDEbuff2:ABCDE]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker基础]]></title>
    <url>%2F2019%2F04%2F15%2FDocker%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[容器的基本操作启动容器命令:docker run IMAGE [COMMAND] [ARG...] IMAGE:启动容器所使用的操作系统镜像 COMMAND: 运行的命令 AGR: 对应参数 例如：docker run ubuntu echo &#39;Hello World&#39; 这是一个执行单词命令的容器 启动交互式容器命令:docker run -i -t IMAGE /bin/bash -i告诉docker守护进程为容器始终打开标准输入 -t告诉为创建的容器分配一个伪tty终端 例如:docker run -i -t ubuntu /bin/bash 输入exit退出这个bash 查看容器命令: docker ps [-a] [-l] -a指列出所有容器 -l列出最新创建的一个容器 如果没有参数返回正在运行的容器 结果的各参数含义: container Id:docker守护进程在启动容器时为容器分配的唯一id names:docker守护进程为容器自动分配的名字 IMAGE: 所使用的操作系统镜像 COMMAND: 运行的命令 CREATED: 创建时间 命令: docker inspect 容器名 容器名既可以是id,也可以是name. 返回配置信息 自定义容器名 命令:docker run --name=自定义名 -i -t IMAGE /bin/bashordocker run --name 自定义名 -i -t IMAGE /bin/bash 例如: docker run --name=container01 -i -t ubuntu /bin/bash 重新启动停止的容器命令:docker start [-i] 容器名 -i参数以交互的方式重新启动 删除停止的容器命令:docker rm 容器名 docker守护式容器什么是守护式容器 能够长期运行 没有交互式会话 适合运行应用程序和服务 以守护形式运行容器命令: docker run -i -t IMAGE /bin/bash Crtl+P+Q退出bash使得容器在后台运行 附加到运行中的容器:命令: docker attach 容器名 启动守护式容器（重要方式）:命令: docker run -d IMAGE [command] [arg...] -d 告诉run命令启动容器时使用后台的方式，命令结束后容器依旧停止 返回的值的是docker守护进程分配给容器的唯一id 查看容器日志命令: docker logs [-f] [-t] [--tail] 容器名 -f告诉logs一直跟踪日志变化并返回 crtl+C停止 -t在返回的结果上加上时间戳 –tail选项是返回结尾处多少数量的，不加返回所有日志 查看容器内进程命令: docker top 容器名 在运行的容器中启动新进程命令:docker exec [-d][-i][-t] 容器名[COMMAND][ARG...] 停止守护式容器命令:docker stop 容器名 or docker kill 容器名stop发送一个信号给容器，等待容器的停止kill直接停止容器 在容器中部署静态网站设置容器的端口映射命令:run [-P] [-p] -P为容器暴露的所有端口进行映射如:docker run -p -i -t ubuntu /bin/bash -p指定映射哪些容器端口指定容器端口，宿主机端口随机映射:docker run -p 80 -i -t ubuntu /bin/bash同时指定容器和宿主机端口:docker run -p 8080:80 -i -t ubuntu /bin/bash指定ip和容器端口:docker run -p 0.0.0.0:80 -i -t ubuntu /bin/bash指定ip宿主机端口容器端口:docker run -p 0.0.0.0:8080:80 -i -t ubuntu /bin/bash Nginx部署创建映射80端口的交互式容器docker run -p 80 --name web -i -t ubuntu /bin/bash 安装Nginxapt-get install -y nginx 安装文本编辑器vimapt-get install -y vim 创建静态页面mkdir -p /var/www/html cd /var/www/html vim index.html 修改nginx配置文件vim /etc/nginx/sites-enabled/default 把root改为静态网站的位置 运行Nginxnginx 查看容器端口映射情况docker port 容器名 验证网站访问浏览器打开: 主机ip:端口 Docker镜像查看和删除镜像查看docker存储驱动和存储位置命令:docker info列出镜像 列出镜像命令: docker images [option] [REPOSITORY] 无参数显示所有镜像详细信息 +仓库名返回对应所有镜像 -a,–all=false 所有镜像 -f,–filter=[] 显示时过滤条件 –no-trunc 指定不使用阶段的方式显示数据 -q,–quit=false 只显示镜像唯一id 返回信息: REPOSITORY:镜像所属仓库名(一系列镜像的集合) TAG:镜像标签名(默认使用latest对应的镜像) IMAGEID: 镜像唯一id(截断过) CREATED: 镜像创建时间 VIRTUAL: 镜像大小 查看镜像的详细信息命令: docker inspect [options] container|image [container|] -f,–format=”” 例如:docker inspect ubuntu:latest 删除镜像命令: docker rmi [options] IMAGE [image…] -f,–force=false 强制删除镜像 –no-prune=false 保留删除镜像中未打标签的父镜像例如: docker rmi ubuntu:14.04例如: docker rmi ${docker images -q ubuntu}删除仓库中所有镜像 注意一个镜像可能会有多个tag 获取和推送镜像查找镜像docker Hub https://registry.hub.docker.com使用前要注册dockerhub命令: docker search [options] term –automated=false 只显示自动化构建出的镜像 –no-trunc=false 不以截断的方式输出 -s,–star=0 限定显示结果的最低星级 例如: docker search ubuntu 拉取镜像命令: docker pull [options] name:[:tag] -a,–all-tags=false 把仓库中所有匹配到的镜像下载到本地 推送镜像命令: docker push name[:TAG] 构建Docker镜像(保存对容器的修改并再次使用)使用commit 构建镜像命令：docker commit [options] container [repository [:TAG]] -a,–author=”” 指定作者 -m,–message=”” 镜像构建的信息 -p,–pause=true 暂停正在运行的容器 例如: docker commit -a ccc -m ‘nginx’ commit_test(容器) xxx/commit_test1(镜像名) 使用build构建镜像命令: docker build 通过Dockerfile文件构建 创建dockerfile文件1234567# first Dockerfile for testFROM ubuntu:14:04MAINTAINER jxhacker &quot;977242261@qq.com&quot;RUN apt-get upadteRUN apt-install -y nginxEXPOSE 80 使用docker build [options] PATH|URL|-进行构建 –force-rm=false –no-cache=false –pull=false -q,–quiet=false –rm=true -t,–tag=”” 指定构建出镜像的名字 例如:docker build -t=&#39;jxhacker/df_test1&#39; . docker的C/S模式 dockers的C/S模式 remote API restful风格API 连接方式 unix:///var/run/docker.sock(默认是客户端与守护进程通信方式) tcp://host:port fd://socketfd 连接socket:nc -U /var/run/docker.sock -U指明使用socket docker守护进程的配置和操作查看守护进程命令: ps -ef|grep docker命令: sudo status docker or systemctl status docker 使用service命令管理命令: sudo service docker start sudo service docer stop sudo service docker restart docker的启动选项命令: docker -d [options] -D,–debug=false -e,–exec-driver=”native” -g,–graph=”/var/lib/docker” –icc=true -l,–log-level=”info” –label=[] -p,–pidfile=”var/run/docker.pid” dcoker启动配置文件位置:/etc/default/docker Docker的客户端与守护进程的远程访问 第二台安装Docker的服务器 修改Docker守护进程启动选项，区别服务器(/etc/default/docker添加DOCKER_OPTS=”-label_name = docker_server_1”) 保证ClientAPI和ServerAPI版本一致 修改服务器端配置/etc/default/docker添加DOCKER_OPTS=”-label_name = docker_server_1 -H tcp://0.0.0.0:2375” 另一台主机访问curl http://xx.xx.xx.xx:2375/info 修改客户端配置docker -H tcp://xx.xx.xx.xx:2375 info也可以使用环境变量DOCKER_HOSTexport DOCKER_HOST=&quot;tcp://xx.xx.xx.xx:2375&quot;使用完置空那个环境变量export DOCKER_HOST=&quot;&quot; docker容器的网络网络基础Linux虚拟网桥 可以设置ip地址 相当于拥有一个隐藏的虚拟网卡 docker修改docker0地址命令: ifconfig docker0 192.168.200.1 netmask 255.255.255.0 自定义虚拟网桥添加虚拟网桥 sudo brctl addr br0 sudo ifconfig bro 192.168.100.1 netmask 255.255.255.0更改dockers守护进程的启动配置 /etc/default/docker 中添加DOCKER_OPTS值 -b=br0 docker 容器的互联docker运行容器互相连接--icc=truedocker运行容器互相连接 所有容器间连接--link所有容器间连接命令:docker run --link=[container_name]:[alias] [image] [command]例如:docker run -it --name cct3 --link=cct1:webtest jxhacker/cct这种方式即时重新启动容器ip改变还是能互联 运行特定容器间的连接 icc=false –iptable=true –link这样就仅仅允许通过link配置的访问docker 容器与外部网络的连接ip_forward系统是否转发流量ip-forward=true守护进程启动时，设置系统的ip_forwardsysctl net.ipv4.conf.all.forwarding查看数据转发是否开启iptables过滤防火墙系统filter表中包含的链 INPUT FORWARD OUTPUT 例如:sudo iptables -t filter -L -n 容器的数据管理docker容器的数据卷什么是数据卷docker数据卷是经过特殊设计的目录，可以绕过联合文件系统，为一个或多个容器提供访问，它存在的目的在于数据的永久化，它完全独立于容器的生命周期，因此，Docker不会再容器删除时删除挂载的数据卷，也没有类似垃圾回收机制对容器引用的数据卷进行处理。 特点: 数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会拷贝到新初始化的数据卷中 数据卷可以在容器之间共享重用 可以对数据卷中的数据直接修改 数据卷的变化不会影响镜像的更新 卷一直存在，即使挂载数据的容器已经被删除 为容器添加数据卷命令: sudo docker run -v ~/container_data:/data -it ubuntu /bin/bash -v指定数据卷在本机文件系统中的目录和在容器中映射的目录名 例如:docker run -it -v ~/datavolumn:/data ubuntu /binbash 为数据卷添加访问权限命令: docker run -v ~/datavolumn:/data:ro -it ubuntu /bin/bash 只读权限 使用dockerfile构建包含数据卷的镜像 dockerfile指令:VOLUMN[&#39;/data&#39;] 构建完成后:docker run --name dvt3 -it jxhacker/dvt其本地的docker路径自动创建 docker的数据卷容器什么是数据卷容器命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器叫数据卷容器 使用数据卷容器命令:docker run --volumns-from [CONTAINER NAME] –volumns-from指定新建容器所指定的数据卷容器 [CONTAINER NAME]已经挂载数据卷的容器的容器名 例如: docker run -it --name dvt4 jxhacker/dvt docker run -it --name dvt5 --volumn-from dvt4 ubuntu /bin/bash dockers数据卷备份与还原数据备份方法命令: docker run --volumes-from [container name] -v $(pwd):/backup ubuntu tar vcf /backup/backup.tar [container data volumn] 例如: docker run --volumes-from dvt5 -v ~/backup:/backup:wr --name dvt10 ubuntu tar cvf /backup/dvt5.tar /datavolumne1 数据还原方法 docker run --volumes-from [container name] -v $(pwd):/backup ubuntu tar xvf /backup/backup.tar [container data volumn]]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java字节码的文件结构解析]]></title>
    <url>%2F2019%2F04%2F10%2FJava%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1、字节码文件产生缘由java语言在其诞生之初就有一句口号：“一次编写，到处运行”，这句话也表达了大多数开发人员对于冲破平台界限的一种渴望，因为以前的编程语言都不支持跨平台运行。就拿C语言作为一个例子，我们知道在不同的操作系统中的cpu指令集是不一样的例如windows只支持x86系列，linux即有支持ARM的，也有支持x86的，这就导致一个结果——C语言在不同操作系统编译后产生的二进制序列运行效果是不一样的，它就必须得在不同的操作系统上安装不同的编译器才能在不同的操作系统上运行。而Java则用了一个虚拟机的概念，Java的源代码经过编译后产生.class为后缀的文件，这就是我们所说的字节码文件。用一小段代码进行演示（本文其它部分也用该段代码进行讲解）：源代码TestClass.java： package org.fenixsoft.clazz; public class TestClass{ private int m; public int inc(){ return m+1; } } 用javac命令进行编译生成TestClass.class文件，然后用winhex这个16进制编辑器进行查看这种文件可以在所有的Java虚拟机上运行，不管你是什么操作系统。从而实现跨平台运行，虽然不同平台的Java虚拟机的实现各不相同。这种虚拟机是真实操作系统的一个抽象，逻辑上可以理解为一个独立的平台，利用这个平台实现跨操作系统运行。除了平台无关之外，Java虚拟机还实现了语言无关，因为Java虚拟机只和class文件具有“绑定关系”，但是除Java语言外的其它语言如果能编译成class文件的话也能在虚拟机上运行。已经有JRuby和Groovy等语言能在Java虚拟机上运行。总的来说，虚拟机的引入是实现平台无关性和语言无关性的一个关键，对与字节码文件的研究对于理解Java和Java虚拟机有很大的帮助，下面我们就来深入理解一下这个字节码文件的结构。 2、class类文件结构Java的class文件时一组以8位的字节为基础单位的二进制，根据Java虚拟机规定，Class文件格式采用一种类似c语言的结构体来存储数据，这种伪结构中只有两种数据类型：无符号数和表。 无符号数：数据基本的数据类型，以u1、u2、u4、u8分别表示一个字节，2个字节，4个字节和8个字节的无符号数，它可以用老表示数字，索引、数据值或者按照utf-8编码的字符串。 表：由多个无符号数或者其它表作为数据项构成复合数据类型2.1、魔数和class文件版本我从这里开始逐字节分析class文件。每个class文件的头4 个字节称为“魔数”，它的作用的标注文件类型，确定这个文件是否是能被虚拟机接收的class文件，虚拟机之所以不用文件后缀名作为判断依据的原因是文件后缀名可以任意改动。例如本文中TestClass.class文件中的魔数是：0xCAFEBABE（咖啡宝贝……），这个魔数在Java还被称为Oak的时候就已经被定下来了。Java的商标大概就是因此定下来的。紧接着魔数的下面4个字节存储的是Class文件的版本号：第5，6字节是次版本号，第7，8字节是主版本号。Java的版本号是从45开始的，JDK1.1后每个JDK大版本发布主版本号都往上+1，高版本的JDK兼容以前版本的Class文件，但不能运行以后版本的class文件，即使格式没变，虚拟机也拒绝执行。本例中的class文件的次版本号是0x0000，主版本号是0x0034，它是十进制是52，说明我用的JDK版本是JDK1.8。 2.2、常量池常量池的入口在主次版本之后，常量池中存放着class的资源，它与class文件中其它项目关联最大，它也是class文件中第一个出现的表类型的数据项目。常量池入口的的一个大小为2u类型（2个字节）的数据被称为常量池容量计数器（constant_pool_count），代表常量池中的常量数量。本例中的常量池容器计数器值是0x13，其十进制是19，但是这个容量计数器是从1开始的，设计者将第0项做了特殊考虑，是为了满足后面某些指向常量池的数据可能会需要表达“不引用任何常量池”的项目，这种情况下可以把索引值设置为0来表示，所以本例中的常量数量是19-1=18项。这18个常量紧跟在常量计数器后面。下面来介绍在常量池中常量的类型已经其结构。常量池中的每一项常量都是一张表，在JDK1.7之前共有11个结构各不相同的表结构数据，在JDK1.7中为了更好的支持动态语言的调用，又加了三个(CONSTANT_MethodHandle_info,CONSTANT_MethodType_info,CONSTANT_InvokeDynamic_info)，这14种表都有一个共同点，就是表的第一位都是一个u1类型的标志位tag代表当前这个变量数据哪种常量类型。而其它位置的数据并不统一，各具其结构。其具体的结构如下。可以根据这个表逐个分析这些常量，我逐个把这18个常量进行圈出来（可能有点看不清）最左边的箭头是指承接上一层的框框。为了更方便的观察常量池的结构，可以用Javap命令进行可视化输出，在命令行输入 javap -verbose TestClass 我截取常量池部分的输出其中第一列是常量类型，第二列表示引用的常量或者utf8类型常量值，例如第一个常量#1的类型名称是Methodref，引用了第4个和第15个常量，第15个常量是NameAndType类型，值又引用了第七个和第八个常量，第七个和第八个常量又是&lt; init &gt;和()V，第四个常量引用第18个常量，第18个常量值是Java/lang/Object(全限类名)。 2.3、访问标志常量池结束后紧接着的两个字节表示访问标志(access_flag)，这个标志用于识别类或者接口的访问信息。2个字节本来是16个标志位，但是只有8个标志位有用，没有使用到的标志一律为0。本例中TestClass是一个普通类，不是接口、美剧或者注解，被public关键词修饰但没有被声明为final和abstract，所有它的ACC_PUBLIC和ACC_SUPER标志位是1，所以本例中的访问标志是0x0021。 2.4、类索引、父类索引和接口索引集合类索引和父类索引都是一个u2类型的数据而接口索引是一组u2类型数据的集合，class通过这三个数据来确定类的继承关系。类索引用于确定类的全限类名，父索引用于确定这个父类的全限类名，接口索引用于描述这个类实现了哪些接口，因为一个类可以实现多个接口。类索引、父类索引和接口索引按顺序排列在访问标志之后，类索引和父索引分别用一个u2类型的数据，分别指向一个类型是CONSTANT_Class_info类型的类描述符常量，通过其索引值找到CONSTANT_utf8_info中的全限类名字符串。接口索引人口第一项是一个u2类型的数据为接口计数器(interface_count)，表示索引表个数，若没有实现任何接口，其值是0。本例中的类索引是0x0003，父索引是0x0004，分别表示org.fenixsoft/clazz/TestClass和，java/lang/Object。接口计数器是0x0000，无接口实现。 2.5、字段表集合字段表集合分为容量计数器（fields_count)和字段表，字段计数器表示字段表个数。字段表用于描述接口或者类中申明的变量，字段修饰符放在access_flag中，它与访问标志的access_flag相似，具体含义见下表跟随access_flag后面的是两项索引值，name_index和descriptor_index。它们都是对常量池的引用。分别表示字段的简单名称和字段和方法的描述符。字段描述符的作用是描述字段的数据类型、方法的参数列表和返回值，基本数据类型和void类型都用一个大写字符表示，描述符标识字含义见下表 标识字符 含义 B 基本类型byte C 基本类型char D 基本类型double F 基本类型float I 基本类型int J 基本类型long S 基本类型short Z 基本类型boolean V 特殊类型void L 对象类型如java/lang/Object 对于数组类型，每一维度都使用一个前置’[‘描述，如一个整型数组int[]被描述为“[I”，用描述符描述方法时，参数列表严格顺序放在一组小括号里面，如void inc(int a,int b)的描述符是“(II)V”本例中容器计数器的值是0x0001,说明有一个字段表，该字段表access_flag是0x0002,说明类型private，name_index和descriptor_index分别是0x0005和0x0006分别表示m和I说明其类型是int。descriptor_index后面跟一个属性表集合用于存放一些额外的信息。本例属性表计算器是0x0000，说明没有额外信息。 2.6、方法表集合class对方法的描述和对字段的描述几乎采用一样的方式。仅在访问标志和属性表集合有所区别。方法访问标志是： 标志名称 标志值 含义 ACC_PUBLIC 0x0001 方法是否为public ACC_PRIVATE 0x0002 方法是否为private ACC_PROTECTED 0x0004 方法是否为protected ACC_STATIC 0x0008 方法是否为static ACC_FINAL 0x0010 方法是否为final ACC_SYHCHRONRIZED 0x0020 方法是否为synchronized ACC_BRIDGE 0x0040 方法是否是有编译器产生的方法 ACC_VARARGS 0x0080 方法是否接受参数 ACC_NATIVE 0x0100 方法是否为native ACC_ABSTRACT 0x0400 方法是否为abstract ACC_STRICTFP 0x0800 方法是否为strictfp ACC_SYNTHETIC 0x1000 方法是否是有编译器自动产生的 还是以本例子讲解容量计数器是0x0002，说明类中有两个方法(分别是类构造器和源码中的inc)，其中第一个方法访问标志是0x0001说明是public，名称索引和描述符索引分别是0x0007和0x0008，分别表示&lt; init&gt;和()V说明是void返回值，无参数。 接下来是属性集合，其容器计数器是0x0001，说明有个属性表，其中第一个属性表的第一个u2数据表示attribute_name_inde是属性表名称，值是0x0009，对于常量池“code”值，说明是个code属性。code属性表结构如表本例中属性长度是0x0000001D，maxstack是0x0001，maxlocal是0x0001，codelength是0x00000005，code是0x2AB70001B1，下面是exception属性集合，其计数器是0x0000，说明没有异常。下面有一个属性表，计数器是0x0001，值是0x000A，是LineNumberTable属性，用于描述Java源码行号和字节码行号之间的关系。其attribute_name_index是0x000A是属性名，指LineNumberTable，0x00000006是属性长度，0x0001是line_number_table_length,line_number_info包括了start_pc和line_number两个u2数据项。 3、总结本文首先对class文件进行简要介绍，随后对的一个真实的.class文件每个字节进行分析深入了解了它的结构，分析它与源代码之间的关系，本文是了解Java虚拟机的基础知识，以科普为主，如有错误欢迎指正。最后欢迎大家点赞关注]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Java字节码</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSL及其加密通信过程]]></title>
    <url>%2F2019%2F04%2F09%2FSSL%E5%8F%8A%E5%85%B6%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、什么是SSLSSL英文全称Secure Socket Layer，安全套接层，是一种为网络通信提供安全以及数据完整性的安全协议，它在传输层对网络进行加密。它主要是分为两层： SSL记录协议：为高层协议提供安全封装、压缩、加密等基本功能 SSL握手协议：用于在数据传输开始前进行通信双方的身份验证、加密算法的协商、交换密钥OpenSSL是SSL的开源实现，它是作为密码学的安全开发包，提供相当强大全面的功能，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议，并提供了丰富的应用程序供测试或其它目的使用。它一共提供了8中对称加密算法和4中非对称加密算法。 二、HTTPS和SSLHTTP（Hyper TEXT Transfer Protocol超文本传输协议）是目前互联网上应用最为广泛的一种网络协议，用于在Web浏览器和网站服务器之间传递信息，但是HTTP协议以明文的方式发送内容，不提供任何数据加密，攻击者能够很轻易通过抓包的方式截取传输内容并读懂其中的信息，所以HTTP不适合传输一些比较私密的信息，为了解决HTTP这一缺陷，HTTPS（Hyper TEXT Transfer Protocol over Secure Socket Layer）协议出现。HTTPS是在HTTP的基础上加入SSL协议。传输以密文传输，保证数据传输的安全以及确认网站的真实性（数字证书）。 HTTPS=HTTP+SSL 三、SSL加密方式3.1 对称加密与非对称加密在开始之前首先得对理解对称加密与非对称加密这两种加密方式。其中加密过程是 信息+密钥+算法=密文 3.1.1对称加密对称加密实质加密和解密都使用同一个密钥，对称加密只有一个密钥，作为私钥。这就好比现实生活中的钥匙和锁，我将想要传达的信息通过对称加密算法用私钥进行加密，形成密文，然后将这密文传送给同样拥有这把锁的“钥匙”的人，对方就用同样的算法和私钥将密文解密出来。常用的对称加密算法有DES和AES等但是在现实中，这种传输方式并不是特别方便，密钥怎么给对方是一个很关键的问题，而且密钥交给了其他人自己也不是很放心。于是非对称加密出现 3.1.2非对称加密非对称加密是指加密和解密用的是不同密钥，并且是成对存在的。一把称为公钥，能够放心的交给别人，一把是私钥，只能自己保存。其中用公钥加密的信息只能用私钥解密，用私钥加密的信息只能用公钥解密。需要注意的是这里的私钥和密钥都是对应的，就是说我的私钥可以解密用我的公钥加密的信息，但是他人的私钥不能解密用我的公钥加密的信息。常用的非对称加密算法有：RSA，DH，DSA三种 3.2 具体的加密过程我通过一段具体的通信过程来模拟这一加密过程。假设主人公是客户端A和服务端B A：B，你好，我想向你发一段消息，请你把你的公钥给我 B：好的，我的公钥是：xxxxxxx。 A：好的，我收到了你的公钥，我给你发送的消息经过你的公钥加密后是：yyyyyyy。 B：收到，我现在用我的密钥来解密看看。 这就是非对称加密的具体过程，这种方式看上去很安全，但是仔细想想信息真的可靠吗？想一想客户端A的公钥是假的怎么办？如果有一个黑客C也给客户端A发送了一个自己的公钥，而客户端A不知道公钥的正确性，用了C的公钥加密发送，这样一来，信息被C截取的化，信息不久泄露了吗。所以我们得想个办法证明我用的公钥确实是服务端B的公钥。于是数字证书出现！我先抛一段官方的数字证书的概念 数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在Internet上验证通信实体身份的方式，数字证书不是数字身份证，而是身份认证机构盖在数字身份证上的一个章或印（或者说加在数字身份证上的一个签名）。 简单来说数字证书就是一段信息，他内部的信息包括： 签发证书的机构 加密算法 Hash算法 公钥 证书到期时间等 贴一段实际的数字证书我通过查看CSDN的数字证书来帮助理解这一概念，chrome的网页栏一般有“安全”的字样，说明该网站的有数字证书的，数据传输的安全性是可以保证的。再来看看数字证书的内容它里面包含了一系列安全相关信息，在下面我会讲这些信息的用途。另外提一点，数字证书是由权威机构——CA机构发行，我们是绝对信任这个机构的。 为了防止证书颁发的过程中被人修改，又出现了一个数字签名的概念，所谓数字签名就是把证书内容做了一个hash操作生成固定长度的数据发送给服务端B，服务端就能通过自己hash一遍对比发过来的hash来判断内容是否被修改。然而这还是可能被人截取修改内容重新生成hash再发给服务端B，这怎么办呢？出于这个考虑，CA机构在颁发时又会用一个私钥将这个hash加密，这样就防止了证书被修改了。我将该过程图示这里再说一下数字签名，通俗来说就是将要传输的信息通过hash加密后将这个hash用私钥加密，最后得到的东西称之为数字签名。用来验证传输的信息是否被更改，注意的是这个私钥是CA官方私钥。所以最终传送的内容有 正文+数字签名+数字证书 我们梳理一下 第一步 ：客户端A开启一个新的浏览器访问客户端时，会先让A安装一个数字证书，这个证书主要包含的是CA机构的公钥。 第二步：服务端B发来CA机构给自己的证书，通过CA公钥解密被CA私钥加密的hash1，然后再用B的证书里面的hash算法将信息生成一个hash2，通过比较两个hash，若相等，确认这个数字证书是服务端B的。 由于非对称加密算法复杂度和计算量大，对称加密效率高，SSL就将这两种加密算法混合着用，这样安全和效率就都能保证了。其中具体的过程如下： 第一步 客户端A给出 支持的SSL版本+一个随机数+自己支持的加密方式 第二步 服务端B接收到这些信息后确认加密方式+自己的安全证书+一个随机数发给A 第三步 客户端A确认数字证书有效性（验证方法上面已经说明），然后生成一个随机数，并将这个随机数用B的数字证书公钥加密后发送给A。 第四步 服务端B使用自己的私钥解密这个随机数 第五步 A和B通过第二步确定的加密方法将前三个随机数生成一个对话密钥 用来接下来的通信（个人感觉不需要三个随机数，只用最后一个就够了，这样做可能是为了更安全） 于是A和B救恩那个用对称加密的方式快速有效安全的通信了。这就是SSL协议的握手过程，图示如下。 四、总结 本文由https引出SSL，并探讨对称和非对称加密以及数字签名和数字证书的原理，最后介绍SSL具体加密通信过程。若有错误或者改进之处欢迎指正，不胜感激。]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTPS</tag>
        <tag>SSL</tag>
      </tags>
  </entry>
</search>
