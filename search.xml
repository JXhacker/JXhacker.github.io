<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSL及其加密通信过程]]></title>
    <url>%2F2019%2F06%2F01%2FSSL%E5%8F%8A%E5%85%B6%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[SSL及其加密通信过程目录 从HTTP说起 SSL协议在网络模型种的位置 SSL和TLS的关系 SSL协议的构成 几个密码学相关概念 SSL加密传输的过程 为什么不直接用对称加密进行加密传输 非对称加密的传输方式 数字签名 数字证书 证书信任链 SSL握手协议 参考资料 从HTTP说起HTTP（Hyper TEXT Transfer Protocol超文本传输协议）是目前互联网上应用最为广泛的一种网络协议，在网络模型中位于应用层，用于在Web浏览器和网站服务器之间传递信息，但是HTTP协议以明文的方式发送内容，不提供任何数据加密，攻击者能够很轻易截获传输的信息，造成的影响：1.你不希望被看到的信息被看到，2.如果传输的数据是可执行文件而被攻击者修改，这样可能对计算机的损害。 为了解决HTTP这一缺陷，HTTPS（Hyper TEXT Transfer Protocol over Secure Socket Layer）协议出现。HTTPS是在HTTP的基础上加入SSL协议。传输以密文传输，保证数据传输的安全(文件是否被修改)以及确认网站的真实性（确定发送者的真实身份）。 HTTPS=HTTP+SSL SSL协议在网络模型中的位置 SSL和TLS的关系我们在搜SSL的时候，一般是SSL和TLS一起出现的，其实本质上SSL和TLS是一个东西，SSL是1994年美国网景开发的协议，目的是为了解决web通信不安全的问题，1996年发布SSL3.0，1997年一个叫IETF的专门制定互联网协议的任务组试图将SSL进行标准化，并且在SSL3.0的基础上发布TLS1.0，之后SSL就以TLS这个名字出现。最终在1999年被记录到RFC（一系列编号排定的文件，意即“请求协议”，包含了关于Internet的几乎所有重要的文字资料）。 SSL 协议的构成上图最左边是标准的TCP/IP的四层模型，从上到下分别是应用层、传输层、网络层、链路层，而新加入的SSL协议则位于传输层和应用层中间，它利用传输运输层提供的端到端的通信服务为应用层提供加密传输服务。SSL又可以被细分为SSL记录协议和SSL握手协议，这两个协议也是有上下层的关系，SSL记录协议主要是提供数据的封装，压缩，认证，加密等基本功能的支持，SSL握手协议则是利用SSL记录协议提供的这些服务，在实际数据传输开始前双方协商加密算法，交换密钥等。详细过程我们后面再说。 几个密码学相关概念 密钥：在加密或者解密算法中的输入参数 对称加密：加密和解密用的是同一个密钥 非对称加密：加密和解密用的是不同密钥，分别被称为公钥和私钥 公钥：可以被公开的密钥 私钥：不能被公开只能自己保存的密钥 其中公钥和私钥的关系是：用公钥加密的密文只能用对应的私钥进行解密，用私钥加密的密文只能用对应的公钥进行解密。 SSL加密传输的过程为什么不直接用对称加密进行加密传输其实对称加密比非对称加密出现的早，而且它还有相对非对称加密来说更快的加密/解密速度，它管理自己的密钥更加简单，但是为什么没有人用对称加密直接用数据的加密传输呢？ 主要原因还是对称加密的密钥分发困难，就比如说我要下载服务器上的一份文件，如果用对称加密的话首先要做的就是密钥分发，如果直接不附加任何东西的发给你，很可能被别人截获，而密钥被别人截获的话是一间很危险的事情。所以一般不会直接用对称加密进行传输，SSL的做法是通过非对称加密的方式交换对称加密的密钥，再通过对称加密的方式数据传输。 非对称加密的传输方式前面说了对称加密不能直接用于数据加密传输，我们再来看看非对称加密。 利用非对称加密的方式有两种，考虑B要向服务器A下载一份文件，一种做法是A用B的公钥加密，发送过去后B用自己的私钥解密，另一种做法是A用自己的私钥加密，B用A的公钥进行解密。 我们现在看一下第一种方式：A用B的公钥加密，B用自己的私钥解密，想一想这种做法有没有什么问题？ 问题就是A向B发送的数据可能被中间人C截获，由于公钥是公开的，C可以冒充A发送文件给B。B接受到文件后：第一它不知道文件是不是来自A，第二它不知道文件是否被人修改。 我们再看一下第二种方式：A用自己的私钥进行加密，B用A的公钥进行解密。这种方式解决了上面的问题了吗？ 上面的问题确实解决了，如果B能够用A的公钥进行解密顺利的解密，这份文件一定是来自A的，并且文件没有被更改，否则无法顺利解密。 我们再来想一想这种方式好吗。非对称加密是一个比较耗时的过程，如果文件比较大的话，就会产生非常严重的延时，对用户体验极度不好。其实用户B的目的是能够下载到A的并且没有被修改的文件，并没有必要对整个文件进行加密，那如何做到即快速又安全呢？就是数字签名！ 数字签名我们先来看一下数字签名的工作流程 A先对这封Email执行哈希运算得到hash值简称“摘要”，取名h1 然后用自己私钥对摘要加密，生成的东西叫“数字签名” 把数字签名加在Email正文后面，一起发送给B。 B收到邮件后用A的公钥对数字签名解密，成功则代表Email确实来自A，失败说明有人冒充 B对邮件正文执行哈希运算得到hash值，取名h2 B 会对比第4步数字签名的hash值h1和自己运算得到的h2，一致则说明邮件未被篡改。 这样一来是不是完美了？有没有上面致命缺陷？答案是有的。缺陷就是B得到的A的公钥不一定是A的功能，它也是可能被修改的，如果有人把你得到的A的公钥改成自己的，别人就有可能冒充A。需要有其它东西证明A公钥的正确性。那就是数字证书！ 数字证书 数字证书是一个专门的颁发数字证书的机构ca颁发的，他将签发者、A的加密算法、A的公钥、证书到期时间等信息用签发机构的私钥进行加密得到一份数字证书。 我们再来看一下数字证书工作流程： 签名的步骤和上面一样，只是A发送的数据包括文件正文、数字签名、数字证书，接收方B通过CA机构的公钥将数字证书解密得到A公钥等信息，用于后续文件验证等操作。 这个过程还有问题吗？——CA公钥如何验证真假。是不是可以和验证A公钥的方法一样找给CA机构签发证书的CA机构，那这个CA又怎么验证，似乎进入恶性循环… 证书信任链证书认证是一级一级的认证的，我们称最顶部的证书为根证书。操作系统或者浏览器会内置一些根证书，我们对这些证书是据对信任的。 以百度服务器的数字证书为例说明证书信任链。 当client端访问baidu.com的时候，baidu的server会将baidu.com证书发送给client端。 client端的操作系统或者浏览器中内置了根证书，但是client端收到baidu.com这个证书后，发现这个证书不是根证书签发，无法根据本地已有的根证书中的公钥去验证baidu.com证书是否可信。 请求到证书后发现GlobalSign Organization Validation CA - SHA256 - G2证书是由根证书签发，而本地刚好有根证书，于是可以利用根证书中的公钥去验证GlobalSign Organization Validation CA - SHA256 - G2证书，发现验证通过，于是信任GlobalSign Organization Validation CA - SHA256 - G2证书。 GlobalSign Organization Validation CA - SHA256 - G2证书被信任后，可以使用GlobalSign Organization Validation CA - SHA256 - G2证书中的公钥去验证baidu.com证书的可信性。验证通过，于是信任baidu.com证书。 windows可以通过certmgr.msc命令查看系统内置的证书 我们可以在浏览器上查看目标服务器的数字证书 SSL握手协议上面介绍的知识客户端单方向的从服务器获取文件，如果服务器要和客户端进行交互，上面的步骤效率就不是很高，一种做法就是通过上面介绍的方法建立链接生成一个对称加密的密钥，之后用对称加密的方式进行交互，这就是SSL握手协议做的事情。具体步骤如下： 这整个握手过程都是不加密的，整个通话的安全性全在于第三个随机数能不能被破解，虽然理论上这个随机数不能被破解，但是为了足够的安全，他们把这个握手阶段默认的算法改成DH算法。双方只要交换各自的参数就可以算出这个随机数。 其具体过程如下： 通过抓包的方式也可以看到上述整个的握手过程： 参考资料通俗理解数字签名，数字证书和https HTTPS协议、TLS协议、证书认证过程解析 图解SSL/TLS协议]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统文件共享机制及代码演示]]></title>
    <url>%2F2019%2F05%2F25%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E6%9C%BA%E5%88%B6%E5%8F%8A%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[内存inode我们知道inode索引节点是UNIX操作系统的一种数据结构，它包含了与文件系统中各个文件相关的一些重要信息，当用户搜索一个文件时，操作系统会根据文件名在磁盘上的inode表中找到该文件对应的inode，该inode包含文件的属主ID，属主的组ID，文件大小，文件使用磁盘块数量，修改时间等信息。但是在实际操作中，操作系统操作的都是内存上的内容，所以内存中会有磁盘上部分的inode表中的数据或者叫做inode表的一个缓存，用于对inode的快速访问，内存中的这块inode叫做内存inode。 系统文件打开表系统文件打开表（Open file table）存在于内存放中，整个操作系统只维护一张这样的表，用于保存已经打开文件的FCB文件号、共享计数（打开共享）、读写位置、打开模式、修改标志等信息，其中还有一个比较重要的属性就是一个指向内存inode的一个指针，这个指针的作用我们后面会介绍。 用户文件打开表用户文件打开表（File Descriptor table）是每个进程都有的一张表，用于记录用户打开的文件的一些信息，主要的属性有文件描述符fd和 一个指向系统文件打开表项的指针。 不同的共享关系用户文件打开表、系统文件打开表和内存inode的关系如下 同进程复制fd 在同一个进程中共享同一个open file table表项，结果是两个文件共享一个句柄，可以dup()实现。 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;int main()&#123; int fd = open("test.txt",O_RDONLY); int fdcopy = dup(fd); char buff1[10]; char buff2[10]; read(fd, buff1, 5); read(fdcopy, buff2, 5); printf("buff1:%s\n", buff1); printf("buff2:%s\n", buff2); close(fd); close(fdcopy);&#125; 其中test.txt中的数据是： 1ABCDEFGHIJ 结果： 12buff1:ABCDEbuff2:FGHIJ 跨进程复制fd 父进程通过fork命令实现子进程对父进程的一种复制，该父子进程的用户文件打开表一样。 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;int main()&#123; int fd = open("test.txt",O_RDONLY); pid_t pid = fork(); char buff[10]; if(pid &gt; 0)&#123; read(fd, buff, 5); printf("father:%s\n", buff); &#125; else&#123; read(fd, buff, 5); printf("son:%s\n", buff); &#125; &#125; 结果： 12father:ABCDEson:FGHIJ 共享数据独立访问父子进程之间共享数据独立访问 两个进程访问同一个文件，但是其系统文件打开表指向不同。代码和上面的跨进程复制fd几乎一样，只是这个open函数在fork函数之后执行，导致两个进程file ptr分别指向系统文件打开表不同位置。 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;int main()&#123; pid_t pid = fork(); int fd = open("test.txt",O_RDONLY); char buff[10]; if(pid &gt; 0)&#123; read(fd, buff, 5); printf("father:%s\n", buff); &#125; else&#123; read(fd, buff, 5); printf("son:%s\n", buff); &#125; &#125; 结果： 12father:ABCDEson:ABCDE 同一进程之间共享数据独立访问 同一个进程操作同一文件，但是对应的系统文件打开表表项不一样。 123456789101112int main()&#123; int fd1 = open("test.txt",O_RDONLY); int fd2 = open("test.txt", O_RDONLY); char buff1[10]; char buff2[10]; read(fd1, buff1, 5); read(fd2, buff2, 5); printf("buff1:%s\n", buff1); printf("buff2:%s\n", buff2); close(fd1); close(fd2);&#125; 结果： 12buff1:ABCDEbuff2:ABCDE]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker基础]]></title>
    <url>%2F2019%2F04%2F15%2FDocker%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[容器的基本操作启动容器命令:docker run IMAGE [COMMAND] [ARG...] IMAGE:启动容器所使用的操作系统镜像 COMMAND: 运行的命令 AGR: 对应参数 例如：docker run ubuntu echo &#39;Hello World&#39; 这是一个执行单词命令的容器 启动交互式容器命令:docker run -i -t IMAGE /bin/bash -i告诉docker守护进程为容器始终打开标准输入 -t告诉为创建的容器分配一个伪tty终端 例如:docker run -i -t ubuntu /bin/bash 输入exit退出这个bash 查看容器命令: docker ps [-a] [-l] -a指列出所有容器 -l列出最新创建的一个容器 如果没有参数返回正在运行的容器 结果的各参数含义: container Id:docker守护进程在启动容器时为容器分配的唯一id names:docker守护进程为容器自动分配的名字 IMAGE: 所使用的操作系统镜像 COMMAND: 运行的命令 CREATED: 创建时间 命令: docker inspect 容器名 容器名既可以是id,也可以是name. 返回配置信息 自定义容器名 命令:docker run --name=自定义名 -i -t IMAGE /bin/bashordocker run --name 自定义名 -i -t IMAGE /bin/bash 例如: docker run --name=container01 -i -t ubuntu /bin/bash 重新启动停止的容器命令:docker start [-i] 容器名 -i参数以交互的方式重新启动 删除停止的容器命令:docker rm 容器名 docker守护式容器什么是守护式容器 能够长期运行 没有交互式会话 适合运行应用程序和服务 以守护形式运行容器命令: docker run -i -t IMAGE /bin/bash Crtl+P+Q退出bash使得容器在后台运行 附加到运行中的容器:命令: docker attach 容器名 启动守护式容器（重要方式）:命令: docker run -d IMAGE [command] [arg...] -d 告诉run命令启动容器时使用后台的方式，命令结束后容器依旧停止 返回的值的是docker守护进程分配给容器的唯一id 查看容器日志命令: docker logs [-f] [-t] [--tail] 容器名 -f告诉logs一直跟踪日志变化并返回 crtl+C停止 -t在返回的结果上加上时间戳 –tail选项是返回结尾处多少数量的，不加返回所有日志 查看容器内进程命令: docker top 容器名 在运行的容器中启动新进程命令:docker exec [-d][-i][-t] 容器名[COMMAND][ARG...] 停止守护式容器命令:docker stop 容器名 or docker kill 容器名stop发送一个信号给容器，等待容器的停止kill直接停止容器 在容器中部署静态网站设置容器的端口映射命令:run [-P] [-p] -P为容器暴露的所有端口进行映射如:docker run -p -i -t ubuntu /bin/bash -p指定映射哪些容器端口指定容器端口，宿主机端口随机映射:docker run -p 80 -i -t ubuntu /bin/bash同时指定容器和宿主机端口:docker run -p 8080:80 -i -t ubuntu /bin/bash指定ip和容器端口:docker run -p 0.0.0.0:80 -i -t ubuntu /bin/bash指定ip宿主机端口容器端口:docker run -p 0.0.0.0:8080:80 -i -t ubuntu /bin/bash Nginx部署创建映射80端口的交互式容器docker run -p 80 --name web -i -t ubuntu /bin/bash 安装Nginxapt-get install -y nginx 安装文本编辑器vimapt-get install -y vim 创建静态页面mkdir -p /var/www/html cd /var/www/html vim index.html 修改nginx配置文件vim /etc/nginx/sites-enabled/default 把root改为静态网站的位置 运行Nginxnginx 查看容器端口映射情况docker port 容器名 验证网站访问浏览器打开: 主机ip:端口 Docker镜像查看和删除镜像查看docker存储驱动和存储位置命令:docker info列出镜像 列出镜像命令: docker images [option] [REPOSITORY] 无参数显示所有镜像详细信息 +仓库名返回对应所有镜像 -a,–all=false 所有镜像 -f,–filter=[] 显示时过滤条件 –no-trunc 指定不使用阶段的方式显示数据 -q,–quit=false 只显示镜像唯一id 返回信息: REPOSITORY:镜像所属仓库名(一系列镜像的集合) TAG:镜像标签名(默认使用latest对应的镜像) IMAGEID: 镜像唯一id(截断过) CREATED: 镜像创建时间 VIRTUAL: 镜像大小 查看镜像的详细信息命令: docker inspect [options] container|image [container|] -f,–format=”” 例如:docker inspect ubuntu:latest 删除镜像命令: docker rmi [options] IMAGE [image…] -f,–force=false 强制删除镜像 –no-prune=false 保留删除镜像中未打标签的父镜像例如: docker rmi ubuntu:14.04例如: docker rmi ${docker images -q ubuntu}删除仓库中所有镜像 注意一个镜像可能会有多个tag 获取和推送镜像查找镜像docker Hub https://registry.hub.docker.com使用前要注册dockerhub命令: docker search [options] term –automated=false 只显示自动化构建出的镜像 –no-trunc=false 不以截断的方式输出 -s,–star=0 限定显示结果的最低星级 例如: docker search ubuntu 拉取镜像命令: docker pull [options] name:[:tag] -a,–all-tags=false 把仓库中所有匹配到的镜像下载到本地 推送镜像命令: docker push name[:TAG] 构建Docker镜像(保存对容器的修改并再次使用)使用commit 构建镜像命令：docker commit [options] container [repository [:TAG]] -a,–author=”” 指定作者 -m,–message=”” 镜像构建的信息 -p,–pause=true 暂停正在运行的容器 例如: docker commit -a ccc -m ‘nginx’ commit_test(容器) xxx/commit_test1(镜像名) 使用build构建镜像命令: docker build 通过Dockerfile文件构建 创建dockerfile文件1234567# first Dockerfile for testFROM ubuntu:14:04MAINTAINER jxhacker &quot;977242261@qq.com&quot;RUN apt-get upadteRUN apt-install -y nginxEXPOSE 80 使用docker build [options] PATH|URL|-进行构建 –force-rm=false –no-cache=false –pull=false -q,–quiet=false –rm=true -t,–tag=”” 指定构建出镜像的名字 例如:docker build -t=&#39;jxhacker/df_test1&#39; . docker的C/S模式 dockers的C/S模式 remote API restful风格API 连接方式 unix:///var/run/docker.sock(默认是客户端与守护进程通信方式) tcp://host:port fd://socketfd 连接socket:nc -U /var/run/docker.sock -U指明使用socket docker守护进程的配置和操作查看守护进程命令: ps -ef|grep docker命令: sudo status docker or systemctl status docker 使用service命令管理命令: sudo service docker start sudo service docer stop sudo service docker restart docker的启动选项命令: docker -d [options] -D,–debug=false -e,–exec-driver=”native” -g,–graph=”/var/lib/docker” –icc=true -l,–log-level=”info” –label=[] -p,–pidfile=”var/run/docker.pid” dcoker启动配置文件位置:/etc/default/docker Docker的客户端与守护进程的远程访问 第二台安装Docker的服务器 修改Docker守护进程启动选项，区别服务器(/etc/default/docker添加DOCKER_OPTS=”-label_name = docker_server_1”) 保证ClientAPI和ServerAPI版本一致 修改服务器端配置/etc/default/docker添加DOCKER_OPTS=”-label_name = docker_server_1 -H tcp://0.0.0.0:2375” 另一台主机访问curl http://xx.xx.xx.xx:2375/info 修改客户端配置docker -H tcp://xx.xx.xx.xx:2375 info也可以使用环境变量DOCKER_HOSTexport DOCKER_HOST=&quot;tcp://xx.xx.xx.xx:2375&quot;使用完置空那个环境变量export DOCKER_HOST=&quot;&quot; docker容器的网络网络基础Linux虚拟网桥 可以设置ip地址 相当于拥有一个隐藏的虚拟网卡 docker修改docker0地址命令: ifconfig docker0 192.168.200.1 netmask 255.255.255.0 自定义虚拟网桥添加虚拟网桥 sudo brctl addr br0 sudo ifconfig bro 192.168.100.1 netmask 255.255.255.0更改dockers守护进程的启动配置 /etc/default/docker 中添加DOCKER_OPTS值 -b=br0 docker 容器的互联docker运行容器互相连接--icc=truedocker运行容器互相连接 所有容器间连接--link所有容器间连接命令:docker run --link=[container_name]:[alias] [image] [command]例如:docker run -it --name cct3 --link=cct1:webtest jxhacker/cct这种方式即时重新启动容器ip改变还是能互联 运行特定容器间的连接 icc=false –iptable=true –link这样就仅仅允许通过link配置的访问docker 容器与外部网络的连接ip_forward系统是否转发流量ip-forward=true守护进程启动时，设置系统的ip_forwardsysctl net.ipv4.conf.all.forwarding查看数据转发是否开启iptables过滤防火墙系统filter表中包含的链 INPUT FORWARD OUTPUT 例如:sudo iptables -t filter -L -n 容器的数据管理docker容器的数据卷什么是数据卷docker数据卷是经过特殊设计的目录，可以绕过联合文件系统，为一个或多个容器提供访问，它存在的目的在于数据的永久化，它完全独立于容器的生命周期，因此，Docker不会再容器删除时删除挂载的数据卷，也没有类似垃圾回收机制对容器引用的数据卷进行处理。 特点: 数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会拷贝到新初始化的数据卷中 数据卷可以在容器之间共享重用 可以对数据卷中的数据直接修改 数据卷的变化不会影响镜像的更新 卷一直存在，即使挂载数据的容器已经被删除 为容器添加数据卷命令: sudo docker run -v ~/container_data:/data -it ubuntu /bin/bash -v指定数据卷在本机文件系统中的目录和在容器中映射的目录名 例如:docker run -it -v ~/datavolumn:/data ubuntu /binbash 为数据卷添加访问权限命令: docker run -v ~/datavolumn:/data:ro -it ubuntu /bin/bash 只读权限 使用dockerfile构建包含数据卷的镜像 dockerfile指令:VOLUMN[&#39;/data&#39;] 构建完成后:docker run --name dvt3 -it jxhacker/dvt其本地的docker路径自动创建 docker的数据卷容器什么是数据卷容器命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器叫数据卷容器 使用数据卷容器命令:docker run --volumns-from [CONTAINER NAME] –volumns-from指定新建容器所指定的数据卷容器 [CONTAINER NAME]已经挂载数据卷的容器的容器名 例如: docker run -it --name dvt4 jxhacker/dvt docker run -it --name dvt5 --volumn-from dvt4 ubuntu /bin/bash dockers数据卷备份与还原数据备份方法命令: docker run --volumes-from [container name] -v $(pwd):/backup ubuntu tar vcf /backup/backup.tar [container data volumn] 例如: docker run --volumes-from dvt5 -v ~/backup:/backup:wr --name dvt10 ubuntu tar cvf /backup/dvt5.tar /datavolumne1 数据还原方法 docker run --volumes-from [container name] -v $(pwd):/backup ubuntu tar xvf /backup/backup.tar [container data volumn]]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java字节码的文件结构解析]]></title>
    <url>%2F2019%2F04%2F10%2FJava%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1、字节码文件产生缘由java语言在其诞生之初就有一句口号：“一次编写，到处运行”，这句话也表达了大多数开发人员对于冲破平台界限的一种渴望，因为以前的编程语言都不支持跨平台运行。就拿C语言作为一个例子，我们知道在不同的操作系统中的cpu指令集是不一样的例如windows只支持x86系列，linux即有支持ARM的，也有支持x86的，这就导致一个结果——C语言在不同操作系统编译后产生的二进制序列运行效果是不一样的，它就必须得在不同的操作系统上安装不同的编译器才能在不同的操作系统上运行。而Java则用了一个虚拟机的概念，Java的源代码经过编译后产生.class为后缀的文件，这就是我们所说的字节码文件。用一小段代码进行演示（本文其它部分也用该段代码进行讲解）：源代码TestClass.java： package org.fenixsoft.clazz; public class TestClass{ private int m; public int inc(){ return m+1; } } 用javac命令进行编译生成TestClass.class文件，然后用winhex这个16进制编辑器进行查看这种文件可以在所有的Java虚拟机上运行，不管你是什么操作系统。从而实现跨平台运行，虽然不同平台的Java虚拟机的实现各不相同。这种虚拟机是真实操作系统的一个抽象，逻辑上可以理解为一个独立的平台，利用这个平台实现跨操作系统运行。除了平台无关之外，Java虚拟机还实现了语言无关，因为Java虚拟机只和class文件具有“绑定关系”，但是除Java语言外的其它语言如果能编译成class文件的话也能在虚拟机上运行。已经有JRuby和Groovy等语言能在Java虚拟机上运行。总的来说，虚拟机的引入是实现平台无关性和语言无关性的一个关键，对与字节码文件的研究对于理解Java和Java虚拟机有很大的帮助，下面我们就来深入理解一下这个字节码文件的结构。 2、class类文件结构Java的class文件时一组以8位的字节为基础单位的二进制，根据Java虚拟机规定，Class文件格式采用一种类似c语言的结构体来存储数据，这种伪结构中只有两种数据类型：无符号数和表。 无符号数：数据基本的数据类型，以u1、u2、u4、u8分别表示一个字节，2个字节，4个字节和8个字节的无符号数，它可以用老表示数字，索引、数据值或者按照utf-8编码的字符串。 表：由多个无符号数或者其它表作为数据项构成复合数据类型2.1、魔数和class文件版本我从这里开始逐字节分析class文件。每个class文件的头4 个字节称为“魔数”，它的作用的标注文件类型，确定这个文件是否是能被虚拟机接收的class文件，虚拟机之所以不用文件后缀名作为判断依据的原因是文件后缀名可以任意改动。例如本文中TestClass.class文件中的魔数是：0xCAFEBABE（咖啡宝贝……），这个魔数在Java还被称为Oak的时候就已经被定下来了。Java的商标大概就是因此定下来的。紧接着魔数的下面4个字节存储的是Class文件的版本号：第5，6字节是次版本号，第7，8字节是主版本号。Java的版本号是从45开始的，JDK1.1后每个JDK大版本发布主版本号都往上+1，高版本的JDK兼容以前版本的Class文件，但不能运行以后版本的class文件，即使格式没变，虚拟机也拒绝执行。本例中的class文件的次版本号是0x0000，主版本号是0x0034，它是十进制是52，说明我用的JDK版本是JDK1.8。 2.2、常量池常量池的入口在主次版本之后，常量池中存放着class的资源，它与class文件中其它项目关联最大，它也是class文件中第一个出现的表类型的数据项目。常量池入口的的一个大小为2u类型（2个字节）的数据被称为常量池容量计数器（constant_pool_count），代表常量池中的常量数量。本例中的常量池容器计数器值是0x13，其十进制是19，但是这个容量计数器是从1开始的，设计者将第0项做了特殊考虑，是为了满足后面某些指向常量池的数据可能会需要表达“不引用任何常量池”的项目，这种情况下可以把索引值设置为0来表示，所以本例中的常量数量是19-1=18项。这18个常量紧跟在常量计数器后面。下面来介绍在常量池中常量的类型已经其结构。常量池中的每一项常量都是一张表，在JDK1.7之前共有11个结构各不相同的表结构数据，在JDK1.7中为了更好的支持动态语言的调用，又加了三个(CONSTANT_MethodHandle_info,CONSTANT_MethodType_info,CONSTANT_InvokeDynamic_info)，这14种表都有一个共同点，就是表的第一位都是一个u1类型的标志位tag代表当前这个变量数据哪种常量类型。而其它位置的数据并不统一，各具其结构。其具体的结构如下。可以根据这个表逐个分析这些常量，我逐个把这18个常量进行圈出来（可能有点看不清）最左边的箭头是指承接上一层的框框。为了更方便的观察常量池的结构，可以用Javap命令进行可视化输出，在命令行输入 javap -verbose TestClass 我截取常量池部分的输出其中第一列是常量类型，第二列表示引用的常量或者utf8类型常量值，例如第一个常量#1的类型名称是Methodref，引用了第4个和第15个常量，第15个常量是NameAndType类型，值又引用了第七个和第八个常量，第七个和第八个常量又是&lt; init &gt;和()V，第四个常量引用第18个常量，第18个常量值是Java/lang/Object(全限类名)。 2.3、访问标志常量池结束后紧接着的两个字节表示访问标志(access_flag)，这个标志用于识别类或者接口的访问信息。2个字节本来是16个标志位，但是只有8个标志位有用，没有使用到的标志一律为0。本例中TestClass是一个普通类，不是接口、美剧或者注解，被public关键词修饰但没有被声明为final和abstract，所有它的ACC_PUBLIC和ACC_SUPER标志位是1，所以本例中的访问标志是0x0021。 2.4、类索引、父类索引和接口索引集合类索引和父类索引都是一个u2类型的数据而接口索引是一组u2类型数据的集合，class通过这三个数据来确定类的继承关系。类索引用于确定类的全限类名，父索引用于确定这个父类的全限类名，接口索引用于描述这个类实现了哪些接口，因为一个类可以实现多个接口。类索引、父类索引和接口索引按顺序排列在访问标志之后，类索引和父索引分别用一个u2类型的数据，分别指向一个类型是CONSTANT_Class_info类型的类描述符常量，通过其索引值找到CONSTANT_utf8_info中的全限类名字符串。接口索引人口第一项是一个u2类型的数据为接口计数器(interface_count)，表示索引表个数，若没有实现任何接口，其值是0。本例中的类索引是0x0003，父索引是0x0004，分别表示org.fenixsoft/clazz/TestClass和，java/lang/Object。接口计数器是0x0000，无接口实现。 2.5、字段表集合字段表集合分为容量计数器（fields_count)和字段表，字段计数器表示字段表个数。字段表用于描述接口或者类中申明的变量，字段修饰符放在access_flag中，它与访问标志的access_flag相似，具体含义见下表跟随access_flag后面的是两项索引值，name_index和descriptor_index。它们都是对常量池的引用。分别表示字段的简单名称和字段和方法的描述符。字段描述符的作用是描述字段的数据类型、方法的参数列表和返回值，基本数据类型和void类型都用一个大写字符表示，描述符标识字含义见下表 标识字符 含义 B 基本类型byte C 基本类型char D 基本类型double F 基本类型float I 基本类型int J 基本类型long S 基本类型short Z 基本类型boolean V 特殊类型void L 对象类型如java/lang/Object 对于数组类型，每一维度都使用一个前置’[‘描述，如一个整型数组int[]被描述为“[I”，用描述符描述方法时，参数列表严格顺序放在一组小括号里面，如void inc(int a,int b)的描述符是“(II)V”本例中容器计数器的值是0x0001,说明有一个字段表，该字段表access_flag是0x0002,说明类型private，name_index和descriptor_index分别是0x0005和0x0006分别表示m和I说明其类型是int。descriptor_index后面跟一个属性表集合用于存放一些额外的信息。本例属性表计算器是0x0000，说明没有额外信息。 2.6、方法表集合class对方法的描述和对字段的描述几乎采用一样的方式。仅在访问标志和属性表集合有所区别。方法访问标志是： 标志名称 标志值 含义 ACC_PUBLIC 0x0001 方法是否为public ACC_PRIVATE 0x0002 方法是否为private ACC_PROTECTED 0x0004 方法是否为protected ACC_STATIC 0x0008 方法是否为static ACC_FINAL 0x0010 方法是否为final ACC_SYHCHRONRIZED 0x0020 方法是否为synchronized ACC_BRIDGE 0x0040 方法是否是有编译器产生的方法 ACC_VARARGS 0x0080 方法是否接受参数 ACC_NATIVE 0x0100 方法是否为native ACC_ABSTRACT 0x0400 方法是否为abstract ACC_STRICTFP 0x0800 方法是否为strictfp ACC_SYNTHETIC 0x1000 方法是否是有编译器自动产生的 还是以本例子讲解容量计数器是0x0002，说明类中有两个方法(分别是类构造器和源码中的inc)，其中第一个方法访问标志是0x0001说明是public，名称索引和描述符索引分别是0x0007和0x0008，分别表示&lt; init&gt;和()V说明是void返回值，无参数。 接下来是属性集合，其容器计数器是0x0001，说明有个属性表，其中第一个属性表的第一个u2数据表示attribute_name_inde是属性表名称，值是0x0009，对于常量池“code”值，说明是个code属性。code属性表结构如表本例中属性长度是0x0000001D，maxstack是0x0001，maxlocal是0x0001，codelength是0x00000005，code是0x2AB70001B1，下面是exception属性集合，其计数器是0x0000，说明没有异常。下面有一个属性表，计数器是0x0001，值是0x000A，是LineNumberTable属性，用于描述Java源码行号和字节码行号之间的关系。其attribute_name_index是0x000A是属性名，指LineNumberTable，0x00000006是属性长度，0x0001是line_number_table_length,line_number_info包括了start_pc和line_number两个u2数据项。 3、总结本文首先对class文件进行简要介绍，随后对的一个真实的.class文件每个字节进行分析深入了解了它的结构，分析它与源代码之间的关系，本文是了解Java虚拟机的基础知识，以科普为主，如有错误欢迎指正。最后欢迎大家点赞关注]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Java字节码</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
