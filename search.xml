<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java字节码的文件结构解析]]></title>
    <url>%2F2019%2F04%2F10%2FJava%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1、字节码文件产生缘由java语言在其诞生之初就有一句口号：“一次编写，到处运行”，这句话也表达了大多数开发人员对于冲破平台界限的一种渴望，因为以前的编程语言都不支持跨平台运行。就拿C语言作为一个例子，我们知道在不同的操作系统中的cpu指令集是不一样的例如windows只支持x86系列，linux即有支持ARM的，也有支持x86的，这就导致一个结果——C语言在不同操作系统编译后产生的二进制序列运行效果是不一样的，它就必须得在不同的操作系统上安装不同的编译器才能在不同的操作系统上运行。而Java则用了一个虚拟机的概念，Java的源代码经过编译后产生.class为后缀的文件，这就是我们所说的字节码文件。用一小段代码进行演示（本文其它部分也用该段代码进行讲解）：源代码TestClass.java： package org.fenixsoft.clazz; public class TestClass{ private int m; public int inc(){ return m+1; } } 用javac命令进行编译生成TestClass.class文件，然后用winhex这个16进制编辑器进行查看这种文件可以在所有的Java虚拟机上运行，不管你是什么操作系统。从而实现跨平台运行，虽然不同平台的Java虚拟机的实现各不相同。这种虚拟机是真实操作系统的一个抽象，逻辑上可以理解为一个独立的平台，利用这个平台实现跨操作系统运行。除了平台无关之外，Java虚拟机还实现了语言无关，因为Java虚拟机只和class文件具有“绑定关系”，但是除Java语言外的其它语言如果能编译成class文件的话也能在虚拟机上运行。已经有JRuby和Groovy等语言能在Java虚拟机上运行。总的来说，虚拟机的引入是实现平台无关性和语言无关性的一个关键，对与字节码文件的研究对于理解Java和Java虚拟机有很大的帮助，下面我们就来深入理解一下这个字节码文件的结构。 2、class类文件结构Java的class文件时一组以8位的字节为基础单位的二进制，根据Java虚拟机规定，Class文件格式采用一种类似c语言的结构体来存储数据，这种伪结构中只有两种数据类型：无符号数和表。 无符号数：数据基本的数据类型，以u1、u2、u4、u8分别表示一个字节，2个字节，4个字节和8个字节的无符号数，它可以用老表示数字，索引、数据值或者按照utf-8编码的字符串。 表：由多个无符号数或者其它表作为数据项构成复合数据类型2.1、魔数和class文件版本我从这里开始逐字节分析class文件。每个class文件的头4 个字节称为“魔数”，它的作用的标注文件类型，确定这个文件是否是能被虚拟机接收的class文件，虚拟机之所以不用文件后缀名作为判断依据的原因是文件后缀名可以任意改动。例如本文中TestClass.class文件中的魔数是：0xCAFEBABE（咖啡宝贝……），这个魔数在Java还被称为Oak的时候就已经被定下来了。Java的商标大概就是因此定下来的。紧接着魔数的下面4个字节存储的是Class文件的版本号：第5，6字节是次版本号，第7，8字节是主版本号。Java的版本号是从45开始的，JDK1.1后每个JDK大版本发布主版本号都往上+1，高版本的JDK兼容以前版本的Class文件，但不能运行以后版本的class文件，即使格式没变，虚拟机也拒绝执行。本例中的class文件的次版本号是0x0000，主版本号是0x0034，它是十进制是52，说明我用的JDK版本是JDK1.8。 2.2、常量池常量池的入口在主次版本之后，常量池中存放着class的资源，它与class文件中其它项目关联最大，它也是class文件中第一个出现的表类型的数据项目。常量池入口的的一个大小为2u类型（2个字节）的数据被称为常量池容量计数器（constant_pool_count），代表常量池中的常量数量。本例中的常量池容器计数器值是0x13，其十进制是19，但是这个容量计数器是从1开始的，设计者将第0项做了特殊考虑，是为了满足后面某些指向常量池的数据可能会需要表达“不引用任何常量池”的项目，这种情况下可以把索引值设置为0来表示，所以本例中的常量数量是19-1=18项。这18个常量紧跟在常量计数器后面。下面来介绍在常量池中常量的类型已经其结构。常量池中的每一项常量都是一张表，在JDK1.7之前共有11个结构各不相同的表结构数据，在JDK1.7中为了更好的支持动态语言的调用，又加了三个(CONSTANT_MethodHandle_info,CONSTANT_MethodType_info,CONSTANT_InvokeDynamic_info)，这14种表都有一个共同点，就是表的第一位都是一个u1类型的标志位tag代表当前这个变量数据哪种常量类型。而其它位置的数据并不统一，各具其结构。其具体的结构如下。可以根据这个表逐个分析这些常量，我逐个把这18个常量进行圈出来（可能有点看不清）最左边的箭头是指承接上一层的框框。为了更方便的观察常量池的结构，可以用Javap命令进行可视化输出，在命令行输入 javap -verbose TestClass 我截取常量池部分的输出其中第一列是常量类型，第二列表示引用的常量或者utf8类型常量值，例如第一个常量#1的类型名称是Methodref，引用了第4个和第15个常量，第15个常量是NameAndType类型，值又引用了第七个和第八个常量，第七个和第八个常量又是&lt; init &gt;和()V，第四个常量引用第18个常量，第18个常量值是Java/lang/Object(全限类名)。 2.3、访问标志常量池结束后紧接着的两个字节表示访问标志(access_flag)，这个标志用于识别类或者接口的访问信息。2个字节本来是16个标志位，但是只有8个标志位有用，没有使用到的标志一律为0。本例中TestClass是一个普通类，不是接口、美剧或者注解，被public关键词修饰但没有被声明为final和abstract，所有它的ACC_PUBLIC和ACC_SUPER标志位是1，所以本例中的访问标志是0x0021。 2.4、类索引、父类索引和接口索引集合类索引和父类索引都是一个u2类型的数据而接口索引是一组u2类型数据的集合，class通过这三个数据来确定类的继承关系。类索引用于确定类的全限类名，父索引用于确定这个父类的全限类名，接口索引用于描述这个类实现了哪些接口，因为一个类可以实现多个接口。类索引、父类索引和接口索引按顺序排列在访问标志之后，类索引和父索引分别用一个u2类型的数据，分别指向一个类型是CONSTANT_Class_info类型的类描述符常量，通过其索引值找到CONSTANT_utf8_info中的全限类名字符串。接口索引人口第一项是一个u2类型的数据为接口计数器(interface_count)，表示索引表个数，若没有实现任何接口，其值是0。本例中的类索引是0x0003，父索引是0x0004，分别表示org.fenixsoft/clazz/TestClass和，java/lang/Object。接口计数器是0x0000，无接口实现。 2.5、字段表集合字段表集合分为容量计数器（fields_count)和字段表，字段计数器表示字段表个数。字段表用于描述接口或者类中申明的变量，字段修饰符放在access_flag中，它与访问标志的access_flag相似，具体含义见下表跟随access_flag后面的是两项索引值，name_index和descriptor_index。它们都是对常量池的引用。分别表示字段的简单名称和字段和方法的描述符。字段描述符的作用是描述字段的数据类型、方法的参数列表和返回值，基本数据类型和void类型都用一个大写字符表示，描述符标识字含义见下表 标识字符 含义 B 基本类型byte C 基本类型char D 基本类型double F 基本类型float I 基本类型int J 基本类型long S 基本类型short Z 基本类型boolean V 特殊类型void L 对象类型如java/lang/Object 对于数组类型，每一维度都使用一个前置’[‘描述，如一个整型数组int[]被描述为“[I”，用描述符描述方法时，参数列表严格顺序放在一组小括号里面，如void inc(int a,int b)的描述符是“(II)V”本例中容器计数器的值是0x0001,说明有一个字段表，该字段表access_flag是0x0002,说明类型private，name_index和descriptor_index分别是0x0005和0x0006分别表示m和I说明其类型是int。descriptor_index后面跟一个属性表集合用于存放一些额外的信息。本例属性表计算器是0x0000，说明没有额外信息。 2.6、方法表集合class对方法的描述和对字段的描述几乎采用一样的方式。仅在访问标志和属性表集合有所区别。方法访问标志是： 标志名称 标志值 含义 ACC_PUBLIC 0x0001 方法是否为public ACC_PRIVATE 0x0002 方法是否为private ACC_PROTECTED 0x0004 方法是否为protected ACC_STATIC 0x0008 方法是否为static ACC_FINAL 0x0010 方法是否为final ACC_SYHCHRONRIZED 0x0020 方法是否为synchronized ACC_BRIDGE 0x0040 方法是否是有编译器产生的方法 ACC_VARARGS 0x0080 方法是否接受参数 ACC_NATIVE 0x0100 方法是否为native ACC_ABSTRACT 0x0400 方法是否为abstract ACC_STRICTFP 0x0800 方法是否为strictfp ACC_SYNTHETIC 0x1000 方法是否是有编译器自动产生的 还是以本例子讲解容量计数器是0x0002，说明类中有两个方法(分别是类构造器和源码中的inc)，其中第一个方法访问标志是0x0001说明是public，名称索引和描述符索引分别是0x0007和0x0008，分别表示&lt; init&gt;和()V说明是void返回值，无参数。 接下来是属性集合，其容器计数器是0x0001，说明有个属性表，其中第一个属性表的第一个u2数据表示attribute_name_inde是属性表名称，值是0x0009，对于常量池“code”值，说明是个code属性。code属性表结构如表本例中属性长度是0x0000001D，maxstack是0x0001，maxlocal是0x0001，codelength是0x00000005，code是0x2AB70001B1，下面是exception属性集合，其计数器是0x0000，说明没有异常。下面有一个属性表，计数器是0x0001，值是0x000A，是LineNumberTable属性，用于描述Java源码行号和字节码行号之间的关系。其attribute_name_index是0x000A是属性名，指LineNumberTable，0x00000006是属性长度，0x0001是line_number_table_length,line_number_info包括了start_pc和line_number两个u2数据项。 3、总结本文首先对class文件进行简要介绍，随后对的一个真实的.class文件每个字节进行分析深入了解了它的结构，分析它与源代码之间的关系，本文是了解Java虚拟机的基础知识，以科普为主，如有错误欢迎指正。最后欢迎大家点赞关注]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>字节码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSL及其加密通信过程]]></title>
    <url>%2F2019%2F04%2F09%2FSSL%E5%8F%8A%E5%85%B6%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、什么是SSLSSL英文全称Secure Socket Layer，安全套接层，是一种为网络通信提供安全以及数据完整性的安全协议，它在传输层对网络进行加密。它主要是分为两层： SSL记录协议：为高层协议提供安全封装、压缩、加密等基本功能 SSL握手协议：用于在数据传输开始前进行通信双方的身份验证、加密算法的协商、交换密钥OpenSSL是SSL的开源实现，它是作为密码学的安全开发包，提供相当强大全面的功能，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议，并提供了丰富的应用程序供测试或其它目的使用。它一共提供了8中对称加密算法和4中非对称加密算法。 二、HTTPS和SSLHTTP（Hyper TEXT Transfer Protocol超文本传输协议）是目前互联网上应用最为广泛的一种网络协议，用于在Web浏览器和网站服务器之间传递信息，但是HTTP协议以明文的方式发送内容，不提供任何数据加密，攻击者能够很轻易通过抓包的方式截取传输内容并读懂其中的信息，所以HTTP不适合传输一些比较私密的信息，为了解决HTTP这一缺陷，HTTPS（Hyper TEXT Transfer Protocol over Secure Socket Layer）协议出现。HTTPS是在HTTP的基础上加入SSL协议。传输以密文传输，保证数据传输的安全以及确认网站的真实性（数字证书）。 HTTPS=HTTP+SSL 三、SSL加密方式3.1 对称加密与非对称加密在开始之前首先得对理解对称加密与非对称加密这两种加密方式。其中加密过程是 信息+密钥+算法=密文 3.1.1对称加密对称加密实质加密和解密都使用同一个密钥，对称加密只有一个密钥，作为私钥。这就好比现实生活中的钥匙和锁，我将想要传达的信息通过对称加密算法用私钥进行加密，形成密文，然后将这密文传送给同样拥有这把锁的“钥匙”的人，对方就用同样的算法和私钥将密文解密出来。常用的对称加密算法有DES和AES等但是在现实中，这种传输方式并不是特别方便，密钥怎么给对方是一个很关键的问题，而且密钥交给了其他人自己也不是很放心。于是非对称加密出现 3.1.2非对称加密非对称加密是指加密和解密用的是不同密钥，并且是成对存在的。一把称为公钥，能够放心的交给别人，一把是私钥，只能自己保存。其中用公钥加密的信息只能用私钥解密，用私钥加密的信息只能用公钥解密。需要注意的是这里的私钥和密钥都是对应的，就是说我的私钥可以解密用我的公钥加密的信息，但是他人的私钥不能解密用我的公钥加密的信息。常用的非对称加密算法有：RSA，DH，DSA三种 3.2 具体的加密过程我通过一段具体的通信过程来模拟这一加密过程。假设主人公是客户端A和服务端B A：B，你好，我想向你发一段消息，请你把你的公钥给我 B：好的，我的公钥是：xxxxxxx。 A：好的，我收到了你的公钥，我给你发送的消息经过你的公钥加密后是：yyyyyyy。 B：收到，我现在用我的密钥来解密看看。 这就是非对称加密的具体过程，这种方式看上去很安全，但是仔细想想信息真的可靠吗？想一想客户端A的公钥是假的怎么办？如果有一个黑客C也给客户端A发送了一个自己的公钥，而客户端A不知道公钥的正确性，用了C的公钥加密发送，这样一来，信息被C截取的化，信息不久泄露了吗。所以我们得想个办法证明我用的公钥确实是服务端B的公钥。于是数字证书出现！我先抛一段官方的数字证书的概念 数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在Internet上验证通信实体身份的方式，数字证书不是数字身份证，而是身份认证机构盖在数字身份证上的一个章或印（或者说加在数字身份证上的一个签名）。 简单来说数字证书就是一段信息，他内部的信息包括： 签发证书的机构 加密算法 Hash算法 公钥 证书到期时间等 贴一段实际的数字证书我通过查看CSDN的数字证书来帮助理解这一概念，chrome的网页栏一般有“安全”的字样，说明该网站的有数字证书的，数据传输的安全性是可以保证的。再来看看数字证书的内容它里面包含了一系列安全相关信息，在下面我会讲这些信息的用途。另外提一点，数字证书是由权威机构——CA机构发行，我们是绝对信任这个机构的。 为了防止证书颁发的过程中被人修改，又出现了一个数字签名的概念，所谓数字签名就是把证书内容做了一个hash操作生成固定长度的数据发送给服务端B，服务端就能通过自己hash一遍对比发过来的hash来判断内容是否被修改。然而这还是可能被人截取修改内容重新生成hash再发给服务端B，这怎么办呢？出于这个考虑，CA机构在颁发时又会用一个私钥将这个hash加密，这样就防止了证书被修改了。我将该过程图示这里再说一下数字签名，通俗来说就是将要传输的信息通过hash加密后将这个hash用私钥加密，最后得到的东西称之为数字签名。用来验证传输的信息是否被更改，注意的是这个私钥是CA官方私钥。所以最终传送的内容有 正文+数字签名+数字证书 我们梳理一下 第一步 ：客户端A开启一个新的浏览器访问客户端时，会先让A安装一个数字证书，这个证书主要包含的是CA机构的公钥。 第二步：服务端B发来CA机构给自己的证书，通过CA公钥解密被CA私钥加密的hash1，然后再用B的证书里面的hash算法将信息生成一个hash2，通过比较两个hash，若相等，确认这个数字证书是服务端B的。 由于非对称加密算法复杂度和计算量大，对称加密效率高，SSL就将这两种加密算法混合着用，这样安全和效率就都能保证了。其中具体的过程如下： 第一步 客户端A给出 支持的SSL版本+一个随机数+自己支持的加密方式 第二步 服务端B接收到这些信息后确认加密方式+自己的安全证书+一个随机数发给A 第三步 客户端A确认数字证书有效性（验证方法上面已经说明），然后生成一个随机数，并将这个随机数用B的数字证书公钥加密后发送给A。 第四步 服务端B使用自己的私钥解密这个随机数 第五步 A和B通过第二步确定的加密方法将前三个随机数生成一个对话密钥 用来接下来的通信（个人感觉不需要三个随机数，只用最后一个就够了，这样做可能是为了更安全） 于是A和B救恩那个用对称加密的方式快速有效安全的通信了。这就是SSL协议的握手过程，图示如下。 四、总结 本文由https引出SSL，并探讨对称和非对称加密以及数字签名和数字证书的原理，最后介绍SSL具体加密通信过程。若有错误或者改进之处欢迎指正，不胜感激。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>SSL</tag>
      </tags>
  </entry>
</search>
